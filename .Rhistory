# functions tested and working with h.RE: pi.sigmo, pi.CHN, pi.TN
ystart = ceiling(max(y))
w = ceiling(max(x))
length.b = params$n_hpars # pars for h function
length.logphi = params$n_pipars # pars for pi function
length.pars = length.b + length.logphi
debug=FALSE
FIT=list(); AICvalues=NULL
for (m in 1:params$n_models) {
set.seed(m)
pars = rnorm(length.pars, # tot no. pars
params$starting_values, params$sd)
set.seed(m)
tmp0 <- tryCatch.W.E (
fityx(y,x,pars[1:length.b],
hr,ystart,pi.x,
pars[(length.b+1):length(pars)],w,
control=list(),
hessian=TRUE,corrFlag=0.7,debug=FALSE)
)
fit = NA
if(! "error" %in% class(tmp0$value)) {
fit <- tmp0$value
fit$vcov <-  matrix(Matrix::nearPD(fit$vcov)$mat,length.pars,length.pars)
}
FIT[[m]] = fit
# if(is.na(fit[1])) dev=c(dev, 1e12) else dev = c(dev, fit$AIC)
# with the funciton used in this analyses, we add the constraint that the pi.x pars should be negative
# to maintain the sigmoid shape
if(params$pi.function == "pi.sigmo" & params$h.function == "h.RE") {
if(!is.na(fit[1])) {
if(any(is.nan(fit$corr)) | any(fit$par[3:4] > 0)) {
AICvalues=c(AICvalues, 1e12)
} else {
AICvalues=c(AICvalues, fit$AIC)
}
} else {
AICvalues=c(AICvalues, 1e12)
}
} else {
if(!is.na(fit[1])) {
if(any(is.nan(fit$corr))) {
# if(all(fit$b > 0)) {
AICvalues=c(AICvalues, 1e12)
} else {
AICvalues=c(AICvalues, fit$AIC)
}
} else {
AICvalues=c(AICvalues, 1e12)
}
}
}
data.frame(m = 1:params$n_models, modAIC = AICvalues) -> df.AIC
df.AIC %>%
arrange(modAIC) %>%
filter(modAIC <= min(df.AIC$modAIC) + 2) -> tab.AIC
tab.AIC
CV.phat.values <- vector("numeric", length(tab.AIC$m))
for (j in 1:length(tab.AIC$m)) {
fName = params$h.function
CV.phat.values[j] <- phatModels(list(FIT[[tab.AIC$m[j]]]))$CV.phat
# LT2D::phatModels(modList = list(FIT[tab.AIC$m[i]]))$CV.phat
}
(tab.AIC %>%
mutate(CV.phat = CV.phat.values) %>%
filter(CV.phat == min(CV.phat)) -> best_mod[[i]])
fitVU[[i]] = FIT[[best_mod[[i]]$m]]
cvs[[i]] <- best_mod[[i]] %>%
mutate(id_survey = data_clean$id_survey[1],
sample_size = data_clean$samplesize[1])
# tryCatch(print(b), error = function(e) { skip_to_next <<- TRUE})
tryCatch(plotfit.x.red(x[x<=w],fitVU[[i]],nclass=20,nint=100),
# rug(x[x<=w]),
error = function(e) { skip_to_next <<- TRUE})
# if(skip_to_next) { next }
if(skip_to_next) { fName = params$h.function
# GoF for perpendicular distances
GoFx(fitVU[[i]],plot=TRUE)$pvals
# # GoF for forward distances
# fName = params$pi.function
# GoFy_mod(fitVU[[i]],plot=TRUE)$pvals
# # plotfit.smoothfy(fitVU,nclass=32);rug(x=y[x<=w])
# # plotfit.y(y[x<=w & y<=ystart],x,fitVU,nclass=20);rug(x=y[x<=w])
# plotfit.smoothfy(fitVU[[i]],xmax=w)
(LT2D::phatModels(modList = list(fitVU[[i]]), # same as fitVU
n=length(na.omit(data_trunc$cluster_size))) %>%
mutate(id_survey = data_clean$id_survey[1],
sample_size = data_clean$samplesize[1]) -> stats_df_groups[[i]]) }
rug(x[x<=w])
# plotfit.x.red(x[x<=w],fitVU[[i]],nclass=20,nint=100);rug(x[x<=w])
fName = params$h.function
# GoF for perpendicular distances
GoFx(fitVU[[i]],plot=TRUE)$pvals
# # GoF for forward distances
# fName = params$pi.function
# GoFy_mod(fitVU[[i]],plot=TRUE)$pvals
# # plotfit.smoothfy(fitVU,nclass=32);rug(x=y[x<=w])
# # plotfit.y(y[x<=w & y<=ystart],x,fitVU,nclass=20);rug(x=y[x<=w])
# plotfit.smoothfy(fitVU[[i]],xmax=w)
(LT2D::phatModels(modList = list(fitVU[[i]]), # same as fitVU
n=length(na.omit(data_trunc$cluster_size))) %>%
mutate(id_survey = data_clean$id_survey[1],
sample_size = data_clean$samplesize[1]) -> stats_df_groups[[i]])
}
# for (i in 1:3) {
for (i in 26:length(unique(data_clean_tot$id_survey))) {
print(i)
skip_to_next <- FALSE
data_clean <- filter(data_clean_tot, id_survey == unique(id_survey)[i])
plot(data_clean$perp_dist, data_clean$forw_dist,
xlim=c(0,max(data_clean$perp_dist)),
ylim=c(0,max(data_clean$forw_dist)),
xlab = "Perpedincular distance",
ylab = "Forward distance")
par(mfrow = c(1,2))
hist(data_clean$perp_dist, main = "", xlab = "Perpendicular distance (m)")
boxplot(data_clean$perp_dist, ylab = "Perpendicular distance (m)")
no_data <- round(params$trunc_perp_dist_perc*length(data_clean$perp_dist)/100,0) # no. data to be deleted
threshold <- sort(data_clean$perp_dist, decreasing = TRUE)[no_data+1] # threshold
data_trunc <-
data_clean %>%
filter(perp_dist <= threshold)
par(mfrow = c(1,2))
hist(data_trunc$forw_dist, main = "", xlab = "Forward distance (m)")
boxplot(data_trunc$forw_dist, ylab = "Forward distance (m)")
ystart = max(data_trunc$forw_dist) # change this to the desired truncation distance if necessary, e.g.
# ystart = params$trunc_forw_dist_m
data_trunc <-
data_trunc %>%
filter(forw_dist <= ystart)
#### Model fitting
y = data_trunc$forw_dist
x = data_trunc$perp_dist
hr = params$h.function # h.yTRE not compatible with pi.sigmoI
# these functions work: h.RE, h.IP, h.SS, h.okamura
pi.x = params$pi.function # perpendicular distance function used
# functions tested and working with h.RE: pi.sigmo, pi.CHN, pi.TN
ystart = ceiling(max(y))
w = ceiling(max(x))
length.b = params$n_hpars # pars for h function
length.logphi = params$n_pipars # pars for pi function
length.pars = length.b + length.logphi
debug=FALSE
FIT=list(); AICvalues=NULL
for (m in 1:params$n_models) {
set.seed(m)
pars = rnorm(length.pars, # tot no. pars
params$starting_values, params$sd)
set.seed(m)
tmp0 <- tryCatch.W.E (
fityx(y,x,pars[1:length.b],
hr,ystart,pi.x,
pars[(length.b+1):length(pars)],w,
control=list(),
hessian=TRUE,corrFlag=0.7,debug=FALSE)
)
fit = NA
if(! "error" %in% class(tmp0$value)) {
fit <- tmp0$value
fit$vcov <-  matrix(Matrix::nearPD(fit$vcov)$mat,length.pars,length.pars)
}
FIT[[m]] = fit
# if(is.na(fit[1])) dev=c(dev, 1e12) else dev = c(dev, fit$AIC)
# with the funciton used in this analyses, we add the constraint that the pi.x pars should be negative
# to maintain the sigmoid shape
if(params$pi.function == "pi.sigmo" & params$h.function == "h.RE") {
if(!is.na(fit[1])) {
if(any(is.nan(fit$corr)) | any(fit$par[3:4] > 0)) {
AICvalues=c(AICvalues, 1e12)
} else {
AICvalues=c(AICvalues, fit$AIC)
}
} else {
AICvalues=c(AICvalues, 1e12)
}
} else {
if(!is.na(fit[1])) {
if(any(is.nan(fit$corr))) {
# if(all(fit$b > 0)) {
AICvalues=c(AICvalues, 1e12)
} else {
AICvalues=c(AICvalues, fit$AIC)
}
} else {
AICvalues=c(AICvalues, 1e12)
}
}
}
data.frame(m = 1:params$n_models, modAIC = AICvalues) -> df.AIC
df.AIC %>%
arrange(modAIC) %>%
filter(modAIC <= min(df.AIC$modAIC) + 2) -> tab.AIC
tab.AIC
CV.phat.values <- vector("numeric", length(tab.AIC$m))
for (j in 1:length(tab.AIC$m)) {
fName = params$h.function
CV.phat.values[j] <- phatModels(list(FIT[[tab.AIC$m[j]]]))$CV.phat
# LT2D::phatModels(modList = list(FIT[tab.AIC$m[i]]))$CV.phat
}
(tab.AIC %>%
mutate(CV.phat = CV.phat.values) %>%
filter(CV.phat == min(CV.phat)) -> best_mod[[i]])
fitVU[[i]] = FIT[[best_mod[[i]]$m]]
cvs[[i]] <- best_mod[[i]] %>%
mutate(id_survey = data_clean$id_survey[1],
sample_size = data_clean$samplesize[1])
# tryCatch(print(b), error = function(e) { skip_to_next <<- TRUE})
tryCatch(plotfit.x.red(x[x<=w],fitVU[[i]],nclass=20,nint=100),
# rug(x[x<=w]),
error = function(e) { skip_to_next <<- TRUE})
# if(skip_to_next) { next }
if(skip_to_next) { fName = params$h.function
# GoF for perpendicular distances
GoFx(fitVU[[i]],plot=TRUE)$pvals
# # GoF for forward distances
# fName = params$pi.function
# GoFy_mod(fitVU[[i]],plot=TRUE)$pvals
# # plotfit.smoothfy(fitVU,nclass=32);rug(x=y[x<=w])
# # plotfit.y(y[x<=w & y<=ystart],x,fitVU,nclass=20);rug(x=y[x<=w])
# plotfit.smoothfy(fitVU[[i]],xmax=w)
(LT2D::phatModels(modList = list(fitVU[[i]]), # same as fitVU
n=length(na.omit(data_trunc$cluster_size))) %>%
mutate(id_survey = data_clean$id_survey[1],
sample_size = data_clean$samplesize[1]) -> stats_df_groups[[i]]) }
rug(x[x<=w])
# plotfit.x.red(x[x<=w],fitVU[[i]],nclass=20,nint=100);rug(x[x<=w])
fName = params$h.function
# GoF for perpendicular distances
GoFx(fitVU[[i]],plot=TRUE)$pvals
# # GoF for forward distances
# fName = params$pi.function
# GoFy_mod(fitVU[[i]],plot=TRUE)$pvals
# # plotfit.smoothfy(fitVU,nclass=32);rug(x=y[x<=w])
# # plotfit.y(y[x<=w & y<=ystart],x,fitVU,nclass=20);rug(x=y[x<=w])
# plotfit.smoothfy(fitVU[[i]],xmax=w)
(LT2D::phatModels(modList = list(fitVU[[i]]), # same as fitVU
n=length(na.omit(data_trunc$cluster_size))) %>%
mutate(id_survey = data_clean$id_survey[1],
sample_size = data_clean$samplesize[1]) -> stats_df_groups[[i]])
}
# for (i in 1:3) {
for (i in 28:length(unique(data_clean_tot$id_survey))) {
print(i)
skip_to_next <- FALSE
data_clean <- filter(data_clean_tot, id_survey == unique(id_survey)[i])
plot(data_clean$perp_dist, data_clean$forw_dist,
xlim=c(0,max(data_clean$perp_dist)),
ylim=c(0,max(data_clean$forw_dist)),
xlab = "Perpedincular distance",
ylab = "Forward distance")
par(mfrow = c(1,2))
hist(data_clean$perp_dist, main = "", xlab = "Perpendicular distance (m)")
boxplot(data_clean$perp_dist, ylab = "Perpendicular distance (m)")
no_data <- round(params$trunc_perp_dist_perc*length(data_clean$perp_dist)/100,0) # no. data to be deleted
threshold <- sort(data_clean$perp_dist, decreasing = TRUE)[no_data+1] # threshold
data_trunc <-
data_clean %>%
filter(perp_dist <= threshold)
par(mfrow = c(1,2))
hist(data_trunc$forw_dist, main = "", xlab = "Forward distance (m)")
boxplot(data_trunc$forw_dist, ylab = "Forward distance (m)")
ystart = max(data_trunc$forw_dist) # change this to the desired truncation distance if necessary, e.g.
# ystart = params$trunc_forw_dist_m
data_trunc <-
data_trunc %>%
filter(forw_dist <= ystart)
#### Model fitting
y = data_trunc$forw_dist
x = data_trunc$perp_dist
hr = params$h.function # h.yTRE not compatible with pi.sigmoI
# these functions work: h.RE, h.IP, h.SS, h.okamura
pi.x = params$pi.function # perpendicular distance function used
# functions tested and working with h.RE: pi.sigmo, pi.CHN, pi.TN
ystart = ceiling(max(y))
w = ceiling(max(x))
length.b = params$n_hpars # pars for h function
length.logphi = params$n_pipars # pars for pi function
length.pars = length.b + length.logphi
debug=FALSE
FIT=list(); AICvalues=NULL
for (m in 1:params$n_models) {
set.seed(m)
pars = rnorm(length.pars, # tot no. pars
params$starting_values, params$sd)
set.seed(m)
tmp0 <- tryCatch.W.E (
fityx(y,x,pars[1:length.b],
hr,ystart,pi.x,
pars[(length.b+1):length(pars)],w,
control=list(),
hessian=TRUE,corrFlag=0.7,debug=FALSE)
)
fit = NA
if(! "error" %in% class(tmp0$value)) {
fit <- tmp0$value
fit$vcov <-  matrix(Matrix::nearPD(fit$vcov)$mat,length.pars,length.pars)
}
FIT[[m]] = fit
# if(is.na(fit[1])) dev=c(dev, 1e12) else dev = c(dev, fit$AIC)
# with the funciton used in this analyses, we add the constraint that the pi.x pars should be negative
# to maintain the sigmoid shape
if(params$pi.function == "pi.sigmo" & params$h.function == "h.RE") {
if(!is.na(fit[1])) {
if(any(is.nan(fit$corr)) | any(fit$par[3:4] > 0)) {
AICvalues=c(AICvalues, 1e12)
} else {
AICvalues=c(AICvalues, fit$AIC)
}
} else {
AICvalues=c(AICvalues, 1e12)
}
} else {
if(!is.na(fit[1])) {
if(any(is.nan(fit$corr))) {
# if(all(fit$b > 0)) {
AICvalues=c(AICvalues, 1e12)
} else {
AICvalues=c(AICvalues, fit$AIC)
}
} else {
AICvalues=c(AICvalues, 1e12)
}
}
}
data.frame(m = 1:params$n_models, modAIC = AICvalues) -> df.AIC
df.AIC %>%
arrange(modAIC) %>%
filter(modAIC <= min(df.AIC$modAIC) + 2) -> tab.AIC
tab.AIC
CV.phat.values <- vector("numeric", length(tab.AIC$m))
for (j in 1:length(tab.AIC$m)) {
fName = params$h.function
CV.phat.values[j] <- phatModels(list(FIT[[tab.AIC$m[j]]]))$CV.phat
# LT2D::phatModels(modList = list(FIT[tab.AIC$m[i]]))$CV.phat
}
(tab.AIC %>%
mutate(CV.phat = CV.phat.values) %>%
filter(CV.phat == min(CV.phat)) -> best_mod[[i]])
fitVU[[i]] = FIT[[best_mod[[i]]$m]]
cvs[[i]] <- best_mod[[i]] %>%
mutate(id_survey = data_clean$id_survey[1],
sample_size = data_clean$samplesize[1])
# tryCatch(print(b), error = function(e) { skip_to_next <<- TRUE})
tryCatch(plotfit.x.red(x[x<=w],fitVU[[i]],nclass=20,nint=100),
# rug(x[x<=w]),
error = function(e) { skip_to_next <<- TRUE})
# if(skip_to_next) { next }
if(skip_to_next) { fName = params$h.function
# GoF for perpendicular distances
GoFx(fitVU[[i]],plot=TRUE)$pvals
# # GoF for forward distances
# fName = params$pi.function
# GoFy_mod(fitVU[[i]],plot=TRUE)$pvals
# # plotfit.smoothfy(fitVU,nclass=32);rug(x=y[x<=w])
# # plotfit.y(y[x<=w & y<=ystart],x,fitVU,nclass=20);rug(x=y[x<=w])
# plotfit.smoothfy(fitVU[[i]],xmax=w)
(LT2D::phatModels(modList = list(fitVU[[i]]), # same as fitVU
n=length(na.omit(data_trunc$cluster_size))) %>%
mutate(id_survey = data_clean$id_survey[1],
sample_size = data_clean$samplesize[1]) -> stats_df_groups[[i]]) }
rug(x[x<=w])
# plotfit.x.red(x[x<=w],fitVU[[i]],nclass=20,nint=100);rug(x[x<=w])
fName = params$h.function
# GoF for perpendicular distances
GoFx(fitVU[[i]],plot=TRUE)$pvals
# # GoF for forward distances
# fName = params$pi.function
# GoFy_mod(fitVU[[i]],plot=TRUE)$pvals
# # plotfit.smoothfy(fitVU,nclass=32);rug(x=y[x<=w])
# # plotfit.y(y[x<=w & y<=ystart],x,fitVU,nclass=20);rug(x=y[x<=w])
# plotfit.smoothfy(fitVU[[i]],xmax=w)
(LT2D::phatModels(modList = list(fitVU[[i]]), # same as fitVU
n=length(na.omit(data_trunc$cluster_size))) %>%
mutate(id_survey = data_clean$id_survey[1],
sample_size = data_clean$samplesize[1]) -> stats_df_groups[[i]])
}
# for (i in 1:3) {
for (i in 29:length(unique(data_clean_tot$id_survey))) {
print(i)
skip_to_next <- FALSE
data_clean <- filter(data_clean_tot, id_survey == unique(id_survey)[i])
plot(data_clean$perp_dist, data_clean$forw_dist,
xlim=c(0,max(data_clean$perp_dist)),
ylim=c(0,max(data_clean$forw_dist)),
xlab = "Perpedincular distance",
ylab = "Forward distance")
par(mfrow = c(1,2))
hist(data_clean$perp_dist, main = "", xlab = "Perpendicular distance (m)")
boxplot(data_clean$perp_dist, ylab = "Perpendicular distance (m)")
no_data <- round(params$trunc_perp_dist_perc*length(data_clean$perp_dist)/100,0) # no. data to be deleted
threshold <- sort(data_clean$perp_dist, decreasing = TRUE)[no_data+1] # threshold
data_trunc <-
data_clean %>%
filter(perp_dist <= threshold)
par(mfrow = c(1,2))
hist(data_trunc$forw_dist, main = "", xlab = "Forward distance (m)")
boxplot(data_trunc$forw_dist, ylab = "Forward distance (m)")
ystart = max(data_trunc$forw_dist) # change this to the desired truncation distance if necessary, e.g.
# ystart = params$trunc_forw_dist_m
data_trunc <-
data_trunc %>%
filter(forw_dist <= ystart)
#### Model fitting
y = data_trunc$forw_dist
x = data_trunc$perp_dist
hr = params$h.function # h.yTRE not compatible with pi.sigmoI
# these functions work: h.RE, h.IP, h.SS, h.okamura
pi.x = params$pi.function # perpendicular distance function used
# functions tested and working with h.RE: pi.sigmo, pi.CHN, pi.TN
ystart = ceiling(max(y))
w = ceiling(max(x))
length.b = params$n_hpars # pars for h function
length.logphi = params$n_pipars # pars for pi function
length.pars = length.b + length.logphi
debug=FALSE
FIT=list(); AICvalues=NULL
for (m in 1:params$n_models) {
set.seed(m)
pars = rnorm(length.pars, # tot no. pars
params$starting_values, params$sd)
set.seed(m)
tmp0 <- tryCatch.W.E (
fityx(y,x,pars[1:length.b],
hr,ystart,pi.x,
pars[(length.b+1):length(pars)],w,
control=list(),
hessian=TRUE,corrFlag=0.7,debug=FALSE)
)
fit = NA
if(! "error" %in% class(tmp0$value)) {
fit <- tmp0$value
fit$vcov <-  matrix(Matrix::nearPD(fit$vcov)$mat,length.pars,length.pars)
}
FIT[[m]] = fit
# if(is.na(fit[1])) dev=c(dev, 1e12) else dev = c(dev, fit$AIC)
# with the funciton used in this analyses, we add the constraint that the pi.x pars should be negative
# to maintain the sigmoid shape
if(params$pi.function == "pi.sigmo" & params$h.function == "h.RE") {
if(!is.na(fit[1])) {
if(any(is.nan(fit$corr)) | any(fit$par[3:4] > 0)) {
AICvalues=c(AICvalues, 1e12)
} else {
AICvalues=c(AICvalues, fit$AIC)
}
} else {
AICvalues=c(AICvalues, 1e12)
}
} else {
if(!is.na(fit[1])) {
if(any(is.nan(fit$corr))) {
# if(all(fit$b > 0)) {
AICvalues=c(AICvalues, 1e12)
} else {
AICvalues=c(AICvalues, fit$AIC)
}
} else {
AICvalues=c(AICvalues, 1e12)
}
}
}
data.frame(m = 1:params$n_models, modAIC = AICvalues) -> df.AIC
df.AIC %>%
arrange(modAIC) %>%
filter(modAIC <= min(df.AIC$modAIC) + 2) -> tab.AIC
tab.AIC
CV.phat.values <- vector("numeric", length(tab.AIC$m))
for (j in 1:length(tab.AIC$m)) {
fName = params$h.function
CV.phat.values[j] <- phatModels(list(FIT[[tab.AIC$m[j]]]))$CV.phat
# LT2D::phatModels(modList = list(FIT[tab.AIC$m[i]]))$CV.phat
}
(tab.AIC %>%
mutate(CV.phat = CV.phat.values) %>%
filter(CV.phat == min(CV.phat)) -> best_mod[[i]])
fitVU[[i]] = FIT[[best_mod[[i]]$m]]
cvs[[i]] <- best_mod[[i]] %>%
mutate(id_survey = data_clean$id_survey[1],
sample_size = data_clean$samplesize[1])
# tryCatch(print(b), error = function(e) { skip_to_next <<- TRUE})
tryCatch(plotfit.x.red(x[x<=w],fitVU[[i]],nclass=20,nint=100),
# rug(x[x<=w]),
error = function(e) { skip_to_next <<- TRUE})
# if(skip_to_next) { next }
if(skip_to_next) { fName = params$h.function
# GoF for perpendicular distances
GoFx(fitVU[[i]],plot=TRUE)$pvals
# # GoF for forward distances
# fName = params$pi.function
# GoFy_mod(fitVU[[i]],plot=TRUE)$pvals
# # plotfit.smoothfy(fitVU,nclass=32);rug(x=y[x<=w])
# # plotfit.y(y[x<=w & y<=ystart],x,fitVU,nclass=20);rug(x=y[x<=w])
# plotfit.smoothfy(fitVU[[i]],xmax=w)
(LT2D::phatModels(modList = list(fitVU[[i]]), # same as fitVU
n=length(na.omit(data_trunc$cluster_size))) %>%
mutate(id_survey = data_clean$id_survey[1],
sample_size = data_clean$samplesize[1]) -> stats_df_groups[[i]]) }
rug(x[x<=w])
# plotfit.x.red(x[x<=w],fitVU[[i]],nclass=20,nint=100);rug(x[x<=w])
fName = params$h.function
# GoF for perpendicular distances
GoFx(fitVU[[i]],plot=TRUE)$pvals
# # GoF for forward distances
# fName = params$pi.function
# GoFy_mod(fitVU[[i]],plot=TRUE)$pvals
# # plotfit.smoothfy(fitVU,nclass=32);rug(x=y[x<=w])
# # plotfit.y(y[x<=w & y<=ystart],x,fitVU,nclass=20);rug(x=y[x<=w])
# plotfit.smoothfy(fitVU[[i]],xmax=w)
(LT2D::phatModels(modList = list(fitVU[[i]]), # same as fitVU
n=length(na.omit(data_trunc$cluster_size))) %>%
mutate(id_survey = data_clean$id_survey[1],
sample_size = data_clean$samplesize[1]) -> stats_df_groups[[i]])
}
