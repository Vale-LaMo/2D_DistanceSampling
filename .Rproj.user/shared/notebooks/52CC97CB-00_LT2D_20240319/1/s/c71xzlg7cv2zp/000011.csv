"0","#### Model fitting"
"0","y = data_trunc$forw_dist"
"0","x = data_trunc$perp_dist"
"0","hr = params$h.function # h.yTRE not compatible with pi.sigmoI"
"0","# these functions work: h.RE, h.IP, h.SS, h.okamura"
"0","pi.x = params$pi.function # perpendicular distance function used"
"0","# functions tested and working with h.RE: pi.sigmo, pi.CHN, pi.TN"
"0","ystart = ceiling(max(y))"
"0","w = ceiling(max(x))"
"0","length.b = params$n_hpars # pars for h function"
"0","length.logphi = params$n_pipars # pars for pi function"
"0","length.pars = length.b + length.logphi"
"0","debug=FALSE"
"0",""
"0"," FIT=list(); AICvalues=NULL"
"0"," for (m in 1:params$n_models) {"
"0","   set.seed(m)"
"0","   pars = rnorm(length.pars, # tot no. pars "
"0","                params$starting_values, params$sd) "
"0","   set.seed(m)"
"0","   tmp0 <- tryCatch.W.E ("
"0","     fityx(y,x,pars[1:length.b],"
"0","           hr,ystart,pi.x,"
"0","           pars[(length.b+1):length(pars)],w,"
"0","           control=list(),"
"0","           hessian=TRUE,corrFlag=0.7,debug=FALSE)"
"0","   )"
"0","   fit = NA"
"0","   if(! ""error"" %in% class(tmp0$value)) {"
"0","     fit <- tmp0$value"
"0","     fit$vcov <-  matrix(Matrix::nearPD(fit$vcov)$mat,length.pars,length.pars)"
"0","   }"
"0","   FIT[[m]] = fit"
"0","   # if(is.na(fit[1])) dev=c(dev, 1e12) else dev = c(dev, fit$AIC)"
"0","   "
"0","   # with the funciton used in this analyses, we add the constraint that the pi.x pars should be negative"
"0","   # to maintain the sigmoid shape"
"0","   if(params$pi.function == ""pi.sigmo"" & params$h.function == ""h.RE"") {"
"0","     if(!is.na(fit[1])) {"
"0","       if(any(is.nan(fit$corr)) | any(fit$par[3:4] > 0)) {"
"0","         AICvalues=c(AICvalues, 1e12)"
"0","       } else {"
"0","         AICvalues=c(AICvalues, fit$AIC)"
"0","       }"
"0","     } else {"
"0","       AICvalues=c(AICvalues, 1e12)"
"0","     }"
"0","   } else {"
"0","     if(!is.na(fit[1])) {"
"0","       if(any(is.nan(fit$corr))) {"
"0","         # if(all(fit$b > 0)) {"
"0","         AICvalues=c(AICvalues, 1e12)"
"0","       } else {"
"0","         AICvalues=c(AICvalues, fit$AIC)"
"0","       }"
"0","     } else {"
"0","       AICvalues=c(AICvalues, 1e12)"
"0","     }"
"0","   }"
"0"," }"
"0","#  fitVU = FIT[[which.min(dev)]]"
"0","#  tabVU = matrix(NA,2,3)"
"0","#  if(is.na(fitVU[1])) tabVU = matrix(NA,2,3) else {"
"0","#    # set.seed(10)"
"0","#    tmp1 <- tryCatch.W.E (boot(fitVU))"
"0","#  if(! ""error"" %in% class(tmp1$value))  tabVU=tmp1$value"
"0","#  }"
"0","# # tabVU # the CIs for the average p and the N of groups are generated by bootstrap"
"0","# if(!is.numeric(unlist(tabVU))) print(""error!"")"
"0","# save(fitVU, file = paste(""output/fitVU_"", params$species_name, "".RData"", sep = """"), compress = FALSE)"
"0","save(FIT, file = paste(""output/FIT_"", params$species_name, "".RData"", sep = """"), compress = FALSE)"
