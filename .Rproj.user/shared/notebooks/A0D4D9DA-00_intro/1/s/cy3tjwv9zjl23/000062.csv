"0","#### Fit 2D distance sampling model using multiple initial value to avoid local minima in the deviance"
"0","y = data$forw_dist"
"0","x = data$perp_dist"
"0","hr = h.RE # h.yTRE non Ã¨ compatibile con pi.sigmoI"
"0","# funzionano h.RE, h.IP, h.SS, h.okamura"
"0","pi.x = pi.sigmo"
"0","# funzionano con h.RE: pi.sigmo, pi.CHN, pi.TN"
"0","ystart = ceiling(max(y))"
"0","w = ceiling(max(x))"
"0","# w = 200"
"0","length.b = 2"
"0","debug=FALSE"
"0",""
"0"," FIT=list(); dev=NULL"
"0"," for (m in 1:10) {"
"0","   pars = rnorm(4, c(0.25,0.25,-4,-1), 3)"
"0","   # pars = rnorm(4, c(0.25,0.25,4,1), 3)"
"0","   set.seed(seed_no)"
"0","   tmp0 <- tryCatch.W.E ("
"0","     fityx(y,x,pars[1:length.b],"
"0","           hr,ystart,pi.x,pars[(length.b+1):length(pars)],w,control=list(),"
"0","           hessian=TRUE,corrFlag=0.7,debug=FALSE)"
"0","   )"
"0","   fit = NA"
"0","   if(! ""error"" %in% class(tmp0$value)) {"
"0","     fit <- tmp0$value"
"0","     fit$vcov <-  matrix(Matrix::nearPD(fit$vcov)$mat,4,4)"
"0","   }"
"0","   FIT[[m]] = fit"
"0","   if(is.na(fit[1])) dev=c(dev, 1e12) else dev = c(dev, fit$val)"
"0"," }"
"0"," fitVU = FIT[[which.min(dev)]]"
"0"," tabVU = matrix(NA,2,3)"
"0"," if(is.na(fitVU[1])) tabVU = matrix(NA,2,3) else {"
"0","   # set.seed(10)"
"0","   tmp1 <- tryCatch.W.E (boot(fitVU))"
"0"," if(! ""error"" %in% class(tmp1$value))  tabVU=tmp1$value"
"0"," }"
"0"," "
"0"," ### Population density"
"0"," # tabVU[2,]/sum(transect.lengths)/(fitVU$w/1000) /2 ## divided by two to get the average over 2 years"
"0"," "
"0"," tabVU"
