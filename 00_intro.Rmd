---
title: "2D distance sampling"
output: html_notebook
---

```{r packages}
library(tidyverse)
library(readxl)

library(mvtnorm)

# if(!"devtools" %in% rownames(installed.packages())) 
#   {install.packages("devtools")}
# devtools::install_github('david-borchers/LT2D')
library(LT2D)
```

```{r functions}
#### Load 2D distance functions
source("functions/com_hfunctions.R")
source("functions/com_pifunctions.R")
source("functions/com_likelihoodutilities.R")
```

Issue: animals avoid both the transects in the absence of observers, and the observers themselves
To correct for the effect of the behavioural response of the animals to either the transects or the observers, Elenga et al. (2020) recommended recording both the forward and perpendicular distances to the observers (2D distance sampling), not just the perpendicular distance. They also recommended multiple-observer protocols.

```{r data-loading}
#### Load dataset
data <- read_excel("data/impala_vlm.xlsx", sheet="template_dataset",
                   col_types = c(rep("numeric", 3),
                                 "date",
                                 "text", "text",
                                 rep("numeric", 5)))
```

```{r data-cleaning}
#### Dealing with NA
data <- 
  data %>% 
  filter(obs != 0,
         perp_dist != "NA",
         forw_dist != "NA")
data$forw_dist <- abs(data$forw_dist)

no_data <- round(8*length(data$perp_dist)/100,0) # no. data to be deleted
threshold <- sort(data$perp_dist, decreasing = TRUE)[no_data+1] # threshold
data <- 
  data %>% 
  filter(perp_dist <= threshold)
seed_no = 16
# seed_no = 12 # vengono NA
```



```{r model-fitting}
#### Fit 2D distance sampling model using multiple initial value to avoid local minima in the deviance
y = data$forw_dist
x = data$perp_dist
hr = h.RE # h.yTRE non Ã¨ compatibile con pi.sigmoI
# funzionano h.RE, h.IP, h.SS, h.okamura
pi.x = pi.sigmo
# funzionano con h.RE: pi.sigmo, pi.CHN, pi.TN
ystart = ceiling(max(y))
w = ceiling(max(x))
# w = 200
length.b = 2
debug=FALSE

 FIT=list(); dev=NULL
 for (m in 1:10) {
   pars = rnorm(4, c(0.25,0.25,-4,-1), 3)
   # pars = rnorm(4, c(0.25,0.25,4,1), 3)
   set.seed(seed_no)
   tmp0 <- tryCatch.W.E (
     fityx(y,x,pars[1:length.b],
           hr,ystart,pi.x,pars[(length.b+1):length(pars)],w,control=list(),
           hessian=TRUE,corrFlag=0.7,debug=FALSE)
   )
   fit = NA
   if(! "error" %in% class(tmp0$value)) {
     fit <- tmp0$value
     fit$vcov <-  matrix(Matrix::nearPD(fit$vcov)$mat,4,4)
   }
   FIT[[m]] = fit
   if(is.na(fit[1])) dev=c(dev, 1e12) else dev = c(dev, fit$val)
 }
 fitVU = FIT[[which.min(dev)]]
 tabVU = matrix(NA,2,3)
 if(is.na(fitVU[1])) tabVU = matrix(NA,2,3) else {
   # set.seed(10)
   tmp1 <- tryCatch.W.E (boot(fitVU))
 if(! "error" %in% class(tmp1$value))  tabVU=tmp1$value
 }
 
 ### Population density
 # tabVU[2,]/sum(transect.lengths)/(fitVU$w/1000) /2 ## divided by two to get the average over 2 years
 
 tabVU
 if(!is.numeric(unlist(tabVU))) print("error, change seed_no to any random number")
 # if(is.na(any(tabVU))) print("error, change seed_no to any random number")


 
```


```{r}
 # vedere https://github.com/david-borchers/LT2D/blob/master/inst/FitsForPaper.r
 # linea nera sigmoide = distribuzione reale animali
 # linea grigia = detection osservata
 # linea tratteggiata = detection corretta tenendo conto della risposta comportamentale
 plotfit.x(x[x<=w],fitVU,nclass=20);rug(x[x<=w])
 fName = "h1"
 GoFx(fitVU,plot=TRUE)$pvals
 plotfit.y(y[x<=w],x,fitVU,nclass=20);rug(x=y[x<=w])
 plotfit.smoothfy(fitVU,nclass=32);rug(x=y[x<=w])
 GoFy(fitVU,plot=TRUE)$pvals # non funziona
 #EHSW:
 phatInterval(fitVU)
 phatInterval(fitVU)*w
 # p(0):
 p0.n=1-Sy(0,0,ystart,fitVU$b,h1);p0.n
 plotfit.smoothfy(fitVU,xmax=0.004)
 
```


